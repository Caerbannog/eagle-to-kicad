#usage "<b>Renumber the parts of a schematic</b><p>"
"This version renumbers only devices with packages (no supply) "
"sorted by sheets and coordinates (vertical/descending, horizontal/ascending).<br>"
"Optional: The starting point for the numeration of parts on the first sheet "
"defines an offset value for the following pages.<br>"
"Example:<br>"
" - 0 = R1 ... Rn<br>"
" - 100 sheet 1: R101..R199 sheet 2: R201..R299 ...<br>"
" - 500 sheet 1: R501..R999 sheet 2: R1001..R1499 ...<br>"
" - 1000 sheet 1: R1001..R1999 sheet 2: R2001..R2999 ...<br>"
"<p>"
"<author>Author: support@cadsoft.de</author>"

#require 6.0000

#include "eagle_to_kicad_include.inc"

// THIS PROGRAM IS PROVIDED AS IS AND WITHOUT WARRANTY OF ANY KIND, EXPRESSED OR IMPLIED

string Version = "ULP Version 4.4.4";

/*
 * CHANGELOG================================================
 * 18.08.2015: Add save command, so sch and pcb are update, save user having to rember
 *             to save the change's
 *             Thanks to: Lachlan  "lachlanusa (at) gmail.com" 
 *
 * 27.02.2015: Programed moded to only add refance numbers
 *             to parts which have no refance numbers
 *             Thanks to: Lachlan  "lachlanusa (at) gmail.com" 
 *
 * 2006.08.23 alf@cadsoft.de
 * correct counter if crossing page by same prefix
 * 2008.01.30 alf@cadsoft.de
 * renumber only the current sheet by start sheet-number * numerical_order
 * 2012-06-21 - corrected sort by Weighting of emphasis in Y-direction
 * alf@cadsoft.de
 */

string Info = "ATTENTION<p>" +
       "Please verify that the corresponding pcb layout (if it existing) " +
       "has been loaded, and is consistant with the PCB.<p>" +
       "Otheriwse renumbering of parts wont work, KiCad sch part to pcb part match wont work !";

string Infoplus =
       " You can change the following sorting parameters:<p>" +
       " descx = 0 (X ascending [left >> right])<br>" +
       " descx = 1 (X descending [right >> left])<br>" +
       " descy = 0 (Y ascending [bottom >> top])<br>" +
       " descy = 1 (Y descending [top >> bottom])<br>";


int    descy = 1;               // set to 0 sorting ascending
int    descx = 0;               // set to 1 sorting descending
int    numerical_order = 0;     // sort from sheet 1, or sort by start counter for sheet
int    emphases = 0;            // weighting of emphases first X second Y or first Y second X

int    actual_sheet = 0;        // 2008.01.30
int    only_actual_sheet = 0;   // 2008.01.30
string sheet_info        = "";

numeric string OldNames[], NewNames[], Prefix[];
int x[], y[], Index[], Sheet[];
int nrNames = 0;

numeric string SymNames[];     // Device-Name of Symbol
int symsh[];
int SymX[], SymY[];
int Snr = 0;
int Dnr = 0;

string Error = "";
string SymPrefix[];    // holds Refance/prefix - any traling number
string DevPrefix[];
string DevName[];      // holds Refnace/prefix with traling number
string SymDevName[];      // holds Refnace/prefix with traling number

string NoPrefixRenumber = ""; // Prefix do not renumber Testpoints

int    ckx[], cky[], cksh[];
string ckname[];


string cmd;  // holds the script to renumbing in sch
string lib_cmd; // hold's script for building lib pads
string pcb_cmd; // Hold scrtip for removeing via's and adding pads in it's place.
string sch_cmd; // Hold script for sch pad's add.

string c;

real Grid = 100; // in 100 Mil
string lbr[], dev[], sym[];


int maxRefNumber = 0;   // Hold the maxium refance number on this schmatic
// this will be the start of the number parts which dont have a refance

int wire_Sx[];
int wire_Sy[];
int wire_Ex[];
int wire_Ey[];
int wireCount;
int noconnect_via_count;


// Pad buffer
int pad_size[];  // hold list of pads size
int pad_drill[];  // hold list of pad drill size.
int pad_shape[]; // hold list of pad shaps
string pac_name[]; // Package name
string dev_name[]; // Device name
int pad_buffer_size;

int pad_count;
string pac_prefix = "VPAC";
string dev_prefix = "VPDEV";
int sch_pad_X = 0;
int sch_pad_Y = 0;
int sch_net_count = 0;

int enable_via_to_pad = 1;
int docment_via_to_pad = 1;
int libsetup = 0;

string WorkPath;
string CurrentLbrName = "vpad";

string shapeTablePad[] = {"Square", "Round", "Octagon"};

string schname = "";

string outputPath = EAGLE_HOME + '/';
string myULP_HOME = EAGLE_HOME + '/';

string infoTargetDirectory  = "<h3>Set the target directory for the KiCad files.</h3>"+
                             "<b>Note this directory should be a clean directory"+
                             "With out any other file's, as the contents may be<center><font color=\"red\">OVER WRITTEN WITHOUT WARNING!</b></center>";

string infoULPdir           = "<b>Eagle ULP conversion script location</b>";

string ULP_Path;
char bkslash = '/';
int pos = strrchr(argv[0], bkslash);


//--------------------------------------------------------------------------------
//Returns 1, if EAGLE is running under Windows (0 for Linux/Mac)
//
int IsWindows()
{
  if ((strsub(argv[0],0,1)=="/") && (strsub(argv[0],0,2)!="//"))
    return 0;
  return 1;
}


//--------------------
// check for existing file
// Return's 1 if found
int check_for_exist_file(string FileName) {
  string a[];
  int n = fileglob(a, FileName);
  if (n == 0) return 0;
  else return 1;
}



//--------------------------------------------------------------------------------
// Returns the index of the first digit of the numeric part of Name
// -1 indicates there is no numeric part in Name
int GetNumberIndex(string Name)
{
  int l = strlen(Name) - 1;
  for (int Index = l; Index >= 0; --Index) {
      if (!isdigit(Name[Index]))
         return Index < l ? Index + 1 : -1;
      }
  return 0;
}

//--------------------------------------------------------------------------------
// return Refance with out traling number
// 
string prefix(string name) {     // Prefix of Device
  int num = GetNumberIndex(name);
  if (num < 1)
    return name;
  else {
    string pfx = name;
    pfx[num] = 0;   //  put in 0 to termant string
    return pfx;
  }
}

void DescendingY(void) {
  for (int ny = 0;  ny < nrNames ; ny++) {
    y[ny] = 0 - y[ny];
  }
  return;
}

void DescendingX(void) {
  for (int nx = 0;  nx < nrNames ; nx++) {
    x[nx] = 0 - x[nx];
  }
  return;
}

void SortElements(void) {
  // Sorts the elements according to their location, first by ascending
  // x coordinates, then by ascending y coordinates.
  // If you prefer a different kind of sorting, you can implement this here.
  // As a result, the integer array Index[] must contain the new sequence
  // in which to renumber the elements.

  // 2008-07-24 alf, weighting of emphases first X second Y or first Y second X

  if (descy) DescendingY();
  if (descx) DescendingX();

  if(!numerical_order)
  {
    if (!emphases)
      sort(nrNames, Index, NewNames, Sheet, x, y);
    else
      sort(nrNames, Index, NewNames, Sheet, y, x);
  }
  else {
    if (!emphases) sort(nrNames, Index, Sheet, NewNames, x, y);
    if (emphases) sort(nrNames, Index, Sheet, NewNames, y, x); // 2012-06-21 correct sort on emphases
  }
  if (descy) DescendingY();
  if (descx) DescendingX();
  return;
}


void CheckSameOrigin(int chk) {  // eagle can not rename an element
                                 // if another element is on the same coordinate
  int index[];
  string checklist, h;
  sort(chk, index, cksh, ckx, cky);
  for (int n = 0; n < nrNames; n++) {
    if(ckx[index[n]] == ckx[index[n+1]] && cky[index[n]] == cky[index[n+1]] && cksh[index[n]] == cksh[index[n+1]]) {
      sprintf(h, "%s & %s on same coordinate (%d %d) mil in sheet %d\n",
                  ckname[index[n]], ckname[index[n+1]],
                  ckx[index[n]],
                  cky[index[n]],
                  cksh[index[n]]);
      checklist += h;
    }
  }
  if (checklist) {
    dlgDialog("Check coordinates") {
      dlgLabel("Eagle can not rename elements that are placed at the same position!");
      dlgHBoxLayout {
        dlgSpacing(300);
      }
      dlgTextView(checklist);
      dlgHBoxLayout {
        dlgPushButton("Break") dlgAccept();
        dlgStretch(1);
      }
    };
    exit(0);
  }
  return;
}

//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
void GenerateNames(void) {
  string memprefix = "";
  int mem_sh = 0;
  if(!numerical_order) {
    // Generates new numeric parts to the element names in NewNames
    int k;
    for (int n = 0; n <= nrNames - 1; ++n)
    {
      if (memprefix != NewNames[Index[n]])   // Start of new Refance prefix name ?
      {
         memprefix = NewNames[Index[n]];
         //         k = 0;                             // Reset to zero
         k = maxRefNumber;
      }
      sprintf(NewNames[Index[n]], "%s%d", NewNames[Index[n]], ++k);
    }
  }
  else {   // renumber sheets by 100.. 200.. 300..
    string h;
    int newdevnr;
    for(int n = 0; n < nrNames  ; ++n) {
      if (memprefix != NewNames[Index[n]])
      {
         memprefix = NewNames[Index[n]];
         newdevnr = numerical_order * Sheet[Index[n]] +1;
      }
      if (mem_sh != Sheet[Index[n]])
      {  // a new Sheet is starting by old prefix *** 2006.08.23 alf@cadsoft.de
        mem_sh = Sheet[Index[n]];
        newdevnr = numerical_order * Sheet[Index[n]] +1;
      }
      sprintf(NewNames[Index[n]], "%s%d", NewNames[Index[n]], newdevnr);
      newdevnr++;
      if (newdevnr-(Sheet[Index[n]]*numerical_order) >= numerical_order)
      {
        sprintf(h, "<qt><nobr>More parts with prefix '%s' than starting point %d on sheet %d<br>Start the ulp with <b>numerical order</b> >= %d</nobr>",
                memprefix, numerical_order, Sheet[Index[n]], numerical_order*10);
        dlgMessageBox(h, "Break");
        exit(0);
      }
    }
  }
  return;
}

//--------------------------------------------------------------------------------
// output script for renumber part
//--------------------------------------------------------------------------------
void Rename(int x, int y, string New) {
  // Generates the EAGLE command necessary to change element name Old to New
  sprintf(c, "Name '%s' (%d %d);#209\n", New, x, y);
  cmd += c;
  return;
}

//--------------------------------------------------------------------------------
// check for existing file
// Returns 1 if found.
//
int exist_file(string FileName)
{
  string a[];
  int n = fileglob(a, FileName);
  if (n == 0) return 0;
  else return 1;
}

//--------------------------------------------------------------------------------
//
string get_project_path() {
  if (board)     board(B)     return(filedir(B.name));
  if (schematic) schematic(B) return(filedir(B.name));
  if (library)   library(B)   return(filedir(B.name));
}

//--------------------------------------------------------------------------------
// Generates an EAGLE script file that does the whole renumbering.
// The tricky part here is that we cannot rename an element to a name
// that already exists in the schematic (which, e.g. might be necessary if
// we had to swap the names of two elements). Therefore we have to
// use a ScratchName wherever this is necessary.
// If there is nothing to do, the resulting script file will be empty.
void GenerateScript(void)
{
  string ScratchName;
  int sch = 0;
  int n;
  for ( n = 0; n < nrNames; ++n) {
    if (Sheet[Index[n]] != sch) {
      sch = Sheet[Index[n]];              // *** change sheet
      sprintf(c, "Edit .s%d;\n", sch);
      cmd += c;
    }
    sprintf( ScratchName, "$%d_%d_$", sch, n);
    Rename(x[Index[n]],y[Index[n]], ScratchName); // output script for renumber part
  }
  for ( n = 0; n < nrNames; ++n) {
    if (Sheet[Index[n]] != sch) {
      sch = Sheet[Index[n]];              // *** change sheet
      sprintf(c, "Edit .s%d;\n", sch);
      cmd += c;
    }
    Rename(x[Index[n]],y[Index[n]], NewNames[Index[n]]); // output script for renumber part
  }
  return;
}

//--------------------------------------------------------------------------------
// *** check collision before rename ***
//--------------------------------------------------------------------------------
string CheckNames(void) {
  string new_name = ";";
  string h;

  for (int Dn = 0; Dn < Dnr; Dn++ ) {
    for (int Sn = 0; Sn < Snr; Sn++) {
      if (DevPrefix[Dn] == SymPrefix[Sn]) {
        sprintf(h, "# Do not use Prefix %s on Device with Package (%s) and Device without Package (%s)\n",
                            SymPrefix[Sn], DevName[Dn], SymDevName[Sn]);
        Error += h;
        break;
        }
      }
    }
  for (int n = 0; n < nrNames - 1; ++n) {     // make a long string
    new_name += NewNames[n] + ";";
  }

  for (int xx = 0; xx < Snr - 1; xx++) {
    string sd = SymNames[xx];
    if(sd[0] == '$') {                       // if first character is a $ on Symbolname
      Error +=  "# Do not use $ character at first position in device names\n";
      sprintf(h, "# RENAME %s at (%.4f %.4f) - sheet %d before running this ULP again' (%.4f %.4f)\n",
                              SymNames[xx], SymX[xx] / 1000.0, SymY[xx] / 1000.0, symsh[xx], SymX[xx] / 1000.0, SymY[xx] / 1000.0);
      Error += h;
    }
    int s;
    int pos = strrstr(new_name, ";" + SymNames[xx] + ";");
    if (pos > 0 ) {
      for (s = 0; s < nrNames - 1; s++)
      {
        if(NewNames[s] == SymNames[xx])
        {
          break;
        }
      }
      Error +=  "# Collision of symbol name and device name (eg. Frames, Supply ...)\n";
      sprintf(h, "# Rename PREFIX of Device %s at (%.4f %.4f) - sheet %d before renaming %s at (%.4f %.4f) - sheet %d';\n",
                              SymNames[xx], SymX[xx] / 1000.0, SymY[xx] / 1000.0, symsh[xx],
                              OldNames[s], x[s] / 1000.0, y[s] / 1000.0, Sheet[s] );
      Error += h;
    }
  }
  return Error;
}

//--------------------------------------------------------------------------------
void setgridmil (void) {
  sprintf(c, "GRID MIL 100 OFF;\n");
  cmd += c;
  // ## only display layer 94 (symbol) if placed a text
  // ## at symbol origin.  15.06.2004 alf@cadsoft.de
  sprintf(c, "DISPLAY NONE 94 -95 -96;\n");
  cmd += c;
  return;
}

//--------------------------------------------------------------------------------
void visible(UL_SCHEMATIC S) {
  sprintf(c, "DISP NONE ");
  cmd += c;
  S.layers(L) {
    if (L.visible) {
      sprintf(c, "%d ", L.number);
      cmd += c;
    }
  }
  cmd += ";\n";
  return;
}

//--------------------------------------------------------------------------------
// dialog box
// 
void menue(void)
{

  int result;
  int rs = 0;
  string tmpSX;
  int space = 10;
  int saveAsDefault = 1;
  int saveAsDefaultULP_Path = 1;
  string tmpS10 = "";
  
  result = dlgDialog("Vis to Pad hack:" + "  BUILD DATE:" + BUILD_DATE )
      {
        dlgLabel("<b><font color=\"red\">This ULP will change unconnected VIA's to PADS with Same Net name as the VIA's<br>" + 
                 "<font color=\"blue\">This is needed because KiCad dose not support Net Names on VIA'S.!<br>"+
                 "If unconnected VIA's (<i>By that I mean VIA'S which have no track's connected to a PAD</i>)<br>"+
                 "will lose net names, and will not connect to fill's or power plane's!<br>"+
                 "This hack will help out by converting all those unconnected VIA'S to Pads<br>"+
                 "<i>Click on Info for more, information and problem's which is could fix/make!</i><br>"+
                 "<b>NOTE:<i> This hack modifies both the eagle sch and PCB file,  which are saved in the TARGET-DIRECTORY/modified_eagle_files/</i>");
 
        dlgHBoxLayout dlgSpacing(900);
        dlgHBoxLayout
        {
          dlgStretch(0);
          dlgSpacing(space);

          if( strlen( tmpS10 ))
          {
            myULP_HOME = tmpS10;
          }
          else
          {
            tmpSX = cfgget( cfg_SCRIP_ULP, myULP_HOME );
            if( strlen(tmpSX ) )
              myULP_HOME = tmpSX;
          }
          //                dlgMessageBox( myULP_HOME + "/exp-lbrs.ulp");
          if( !(check_for_exist_file( myULP_HOME + "exp-lbrs.ulp" ) &&  check_for_exist_file( myULP_HOME + "eagle-lbr2kicad-1.0.ulp") && check_for_exist_file( myULP_HOME + "renumber-sheet.ulp" )) )
          {
            dlgLabel("<b><font color=\"red\">ULP conversion script files Location Not correct!");
            tmpS10 = myULP_HOME;
            rs = 1;
          }
          else
          {
            dlgLabel("<font color=\"green\">ULP conversion script files Location");
            rs = 0;
            tmpS10 = "";                  
          }
                
          dlgStringEdit(  myULP_HOME );
          dlgCheckBox("Save as default", saveAsDefaultULP_Path );
          dlgPushButton("Edit") { tmpS10 = myULP_HOME = dlgDirectory("Select Targget directory", "C:\\") + '/'; rs = 1; dlgAccept(); };
          dlgPushButton("Info") { if (dlgMessageBox( infoULPdir, "Ok") == 0); };
          dlgStretch(0);

          /* if( !(check_for_exist_file( myULP_HOME + "exp-lbrs.ulp" ) &&  check_for_exist_file( myULP_HOME + "eagle-lbr2kicad-1.0.ulp") && check_for_exist_file( myULP_HOME + "renum.ulp" ) )) */
          /*   { */
                
          /*   } */


        }

        dlgHBoxLayout
        {
          dlgStretch(0);
          dlgSpacing(space);
          dlgLabel("Target Dirctory For KiCAD files");
          tmpSX = cfgget( cfg_TARGET_DIR, outputPath );

          if( strlen(tmpSX ) )
            outputPath = tmpSX;

          dlgStringEdit( outputPath );
          dlgCheckBox("Save as default", saveAsDefault );
          dlgPushButton("Edit") ( outputPath = dlgDirectory("Select Targget directory", "C:\\") + '/' );
          dlgPushButton("Info") { if (dlgMessageBox( infoTargetDirectory, "Ok") == 0); };
          dlgStretch(0);
        }

        dlgVBoxLayout 
        {
          dlgStretch(0);
          dlgHBoxLayout 
          {
            dlgStretch(1);
            dlgPushButton("+OK")
            {
              if( saveAsDefault )
                cfgset( cfg_TARGET_DIR, outputPath );
              /* else */
              /*   cfgset( cfg_TARGET_DIR, "" ); */

              if( saveAsDefaultULP_Path )
                cfgset( cfg_SCRIP_ULP, myULP_HOME );
              /* else */
              /*   cfgset(cfg_TARGET_DIR, "" ); */

              dlgAccept();
            };

            dlgSpacing(space);
            dlgPushButton("-Cancel") dlgReject();
            dlgStretch(0);
            dlgSpacing(space);
          }
          dlgStretch(10);
        }
      };

  if (!result)
    exit (0);
  return ;
}


//--------------------------------------------------------------------------------
// find connected wire to via.
// return 0 if not found, else return 1 if found.
//
//
int findViaWire( int X, int Y, int tablesize )
{
  int i;
  for( i = 0; i < tablesize; i++ )
  {
    if(( X == wire_Sx[ i ]) && ( Y == wire_Sy[ i ]))
      return 1;

    if(( X == wire_Ex[ i ]) && ( Y == wire_Ey[ i ]))
      return 1;
  }
  return 0;  // not found !  
}


//--------------------------------------------------------------------------------
// find connected wire to via.
// return 0 if not found, else return index + 1 if found.
//
//
int findViaPad( int via_size, int via_drill, int via_shape, int tablesize )
{
  int i;
  string t;
  
  for( i = 0; i < tablesize; i++ )
  {
    if(( via_size == pad_size[ i ]) && ( via_drill == pad_drill[ i ]) && ( via_shape == pad_shape[i]) )
    {
      return i + 1;
    }
  }
  return 0;  // not found !  
}


//--------------------------------------------------------------------------------
// Crate lib, if lib exist's delete it, and make new one.
//
void CreateOneLibHeader( UL_LIBRARY LBR )
{
  string c;

  if (exist_file(WorkPath+CurrentLbrName+".lbr"))
  {
     sprintf(c, "REMOVE '%s';\n", WorkPath+CurrentLbrName+".lbr");
     lib_cmd += c; // delete existing lbr
  }
  sprintf(c, "OPEN '~dummy~.lbr';\nCLOSE;\nOPEN '%s.lbr';\n", WorkPath+CurrentLbrName); 
  lib_cmd += c;

  LBR.layers(L)
  {
    sprintf(c, "Layer %d %s;\n", L.number, L.name); lib_cmd += c;
  }
  
  sprintf(c, "Set Wire_bend 2;\nSet Select_factor 0;\nSet Undo_log off;\n");
  lib_cmd += c;
  sprintf(c, "Grid mic;\n");
  lib_cmd += c;
  sprintf(c, "Display All;\n");
  lib_cmd += c;
  lib_cmd += "DESCRIPTION 'TemporyVPADlib';\n\n";
}



//--------------------------------------------------------------------------------
// Add new pad the same size, and type to tempory lib.
//
int add_new_pad( UL_VIA V, UL_LIBRARY LBR )
{
  string c;

  pad_size[ pad_buffer_size ] = V.diameter[ V.start ]; //size of first part
  pad_drill[ pad_buffer_size ] = V.drill;
  pad_shape[ pad_buffer_size ] = V.shape[ V.start ];
  sprintf( pac_name[ pad_buffer_size ], "%s%d", pac_prefix, pad_buffer_size );
  sprintf( dev_name[ pad_buffer_size ], "%s%d", dev_prefix, pad_buffer_size );    


  if( libsetup == 0 ) // is the lib setup ?
  {
    lib_cmd = "";
    CreateOneLibHeader( LBR ); // Open new lib for pads

    sprintf(c, "Edit '%s.SYM';\n", "VPAD");
    lib_cmd += c;
    sprintf(c, "Layer 94;\n");
    lib_cmd += c;
    sprintf(c, "Pin 'VP' Pas None Short R0 Off 0 (0 0);\n");
    lib_cmd += c;
    sprintf(c, "DESCRIPTION '';\n");
    lib_cmd += c;

    libsetup = 1;
  }

  sprintf(c, "\nEDIT '%s.PAC';\n", pac_name[ pad_buffer_size ]);
  lib_cmd += c;
  sprintf(c, "GRID mic;\n");
  lib_cmd += c;
  sprintf( c, "CHANGE DRILL %f;\n", u2mic(pad_drill[ pad_buffer_size ] ));  
  lib_cmd += c;
  sprintf( c, "PAD %f %s R0.0 '%s'(%f %f);\n", u2mic( pad_size[ pad_buffer_size ]), shapeTablePad[ pad_shape[ pad_buffer_size ]], "VP",  u2mic(0), u2mic(0));
  lib_cmd += c;
  sprintf(c, "DESCRIPTION '';\n");
  lib_cmd += c;

  sprintf(c, "\nEDIT '%s.DEV';\n", dev_name[ pad_buffer_size ]);
  lib_cmd += c;
  sprintf(c, "DESCRIPTION 'VIAPAD';\n");
  lib_cmd += c;
  sprintf(c, "PREFIX 'VP';\n");  
  lib_cmd += c;
  sprintf(c, "VALUE Off;\n");
  lib_cmd += c;
  sprintf(c, "CHANGE Addlevel  Next;\n");
  lib_cmd += c;
  sprintf(c, "CHANGE Swaplevel 0;\n");
  lib_cmd += c;
  sprintf(c, "ADD '%s' '%s' (%f %f);\n", "VPAD", "G$1", u2mic(0), u2mic(0));
  lib_cmd += c;
  sprintf(c, "PACKAGE '%s' '';\n", pac_name[ pad_buffer_size ] );
  lib_cmd += c;
  sprintf(c, "CONNECT ALL 'G$1.VP' 'VP';\n");
  lib_cmd += c;
  sprintf(c, "TECHNOLOGY '''''';\n\n" );
  lib_cmd += c;
  pad_buffer_size++;

  //  string t;
  //  sprintf(t, "addnewpad pad_buffer_size=%d", pad_buffer_size );
  //  dlgMessageBox( t);            

  return pad_buffer_size;

}


//--------------------------------------------------------------------------------
//
//
//--------------------------------------------------------------------------------
int main()
{
  string fname;
  string tmpSX;

  if (pos >= 0) 
  { 
    string tmpSX = ""; 
    ULP_Path = strsub(argv[0], 0, pos + 1);

    tmpSX = cfgget( cfg_SCRIP_ULP, myULP_HOME );
    if( strlen(tmpSX ) )
      myULP_HOME = tmpSX;
    else
      myULP_HOME = ULP_Path; 
  }


  if( schematic || library )
  {
    dlgMessageBox("<b><h2>This ulp can only be run with the target pcb board open!</h2></b>");             
    exit( EXIT_FAILURE );
  }


  // Check to see if there is a config file path set for target directory
  if( strlen( tmpSX = cfgget( cfg_TARGET_DIR )) > 0 )
  {
    WorkPath = tmpSX;  // Yes .. so use it.
  }
  else
    WorkPath = get_project_path();  // No so use the default





  board(B) {
    //    schname = filesetext(B.name,".sch");
    //    pcbname = filesetext(B.name,".brd");    

    noconnect_via_count = 0;
    pad_buffer_size = 0;
    
    B.signals(S) {
      wireCount = 0;
      int via_replace = 0;
      string netname = S.name;
      int viaX;
      int viaY;
      
      S.wires(W) {
        wire_Sx[ wireCount ] = W.x1;
        wire_Sy[ wireCount ] = W.y1;        
        wire_Ex[ wireCount ] = W.x2;
        wire_Ey[ wireCount ] = W.y2;        
        wireCount++;
      }
      S.vias(V) {
        // Is there a wire connected to this via ?
        if( findViaWire( V.x, V.y, wireCount ) == 0 ) 
        { // No, so docment and build scripts to add to sch and pcb and temporty lbr
          noconnect_via_count++;

          if( docment_via_to_pad )
          {

          }
          
          if( enable_via_to_pad )
          {

          }
        }  // if( findViaWire( V.x, V.y, wireCount ) == 0 ) 
      }  // vias(V) {
    }  // signals(S) {
  }  // board(B) {


    if( noconnect_via_count > 0 )
      menue();
    

    noconnect_via_count = 0;
    wireCount= 0;

  

  board(B) {
    schname = filesetext(B.name,".sch");
    //    pcbname = filesetext(B.name,".brd");    
    fname = filesetext(B.name, "~fix_via_hack.scr");
    //    fname = "'"+filesetext(B.name, "~fix_via_hack.scr")+"'";      
    sprintf(c, "grid mic;\n");
    cmd += c;
    noconnect_via_count = 0;
    pad_buffer_size = 0;
    
    B.signals(S) {
      wireCount = 0;
      int via_replace = 0;
      string netname = S.name;
      int viaX;
      int viaY;
      
      S.wires(W) {
        wire_Sx[ wireCount ] = W.x1;
        wire_Sy[ wireCount ] = W.y1;        
        wire_Ex[ wireCount ] = W.x2;
        wire_Ey[ wireCount ] = W.y2;        
        wireCount++;
      }
      S.vias(V) {
        // Is there a wire connected to this via ?
        if( findViaWire( V.x, V.y, wireCount ) == 0 ) 
        { // No, so docment and build scripts to add to sch and pcb and temporty lbr
          noconnect_via_count++;


          viaX = V.x;
          viaY = V.y;
          
          if( docment_via_to_pad )
          {
            sprintf(c, "layer %d;\n", 51 ); // select Doc layer
            pcb_cmd += c;
            sprintf(c, "CHANGE FONT VECTOR;\n"); // select Font
            pcb_cmd += c;
            sprintf(c, "CHANGE SIZE 0.1;\n");
            pcb_cmd += c;
            sprintf( c, "TEXT '%s' R0 (%f %f);\n", S.name, u2mm(V.x) + 0.1, u2mm(V.y));
            pcb_cmd += c;          
            sprintf(c, "SET WIRE_BEND 7;\n");
            pcb_cmd += c;
            sprintf( c, "wire '%s' %f (%f %f) (%f %f );\n", S.name,  100.0,  u2mic(V.x), u2mic(V.y), u2mic(V.x - ( V.diameter[V.start] /2)), u2mic(V.y + ( V.diameter[V.start] /4 )));
            pcb_cmd += c;
            sprintf( c, "wire '%s' %f (%f %f) (%f %f );\n", S.name,  100.0, u2mic(V.x - ( V.diameter[V.start] /2)), u2mic(V.y - ( V.diameter[V.start] /4 )), u2mic(V.x), u2mic(V.y));
            pcb_cmd += c;
          }
          
          if( enable_via_to_pad )
          {
            int idx;
            string t;
            
            via_replace++;  // Mark for clean up

            idx = findViaPad( V.diameter[V.start], V.drill, V.shape[V.start], pad_buffer_size );
            if( idx == 0 )
            {
              UL_LIBRARY L;              
              B.libraries(LBR){
                L = LBR;
              }
              idx = add_new_pad(V, L);
            }
            idx--; // ajust to base zero

            //            idx = 0; // ??? ajust to base zero            

            sprintf(c, "DISPLAY NONE;\n");  // dispaly only via layer for delete
            pcb_cmd += c;
            sprintf(c, "DISPLAY 18;\n");  // show via layer
            pcb_cmd += c;
            sprintf(c, "RIPUP (%f %f);\n", u2mic(V.x), u2mic(V.y));  // remove the via
            pcb_cmd += c;
            sprintf(c, "DISPLAY ALL;\n");  // show via layer
            pcb_cmd += c;
            
            sprintf(c, "grid mic;\n");
            sch_cmd += c;
            sprintf(c, "add '%s@%s' '%s%d' (%f %f);\n", dev_name[idx], WorkPath+CurrentLbrName, "VP_", pad_count, u2mic(sch_pad_X), u2mic(sch_pad_Y ) - ( sch_net_count * 2540.0 ));  // add the pad sch
            sch_cmd += c;
            sprintf(c, "move '%s%d' (%f %f);\n", "VP_", pad_count, u2mic(V.x), u2mic(V.y));  // move the Pad into where the via was
            pcb_cmd += c;

            pad_count++;
          }
        }  // if( findViaWire( V.x, V.y, wireCount ) == 0 ) 
      }  // vias(V) {
      if( via_replace ) // Did we replace any via's wit pad's on the signal ?
      {
        via_replace = 0;
        sprintf(c, "NET %s (%f %f )( %f %f );\n", S.name, u2mic(sch_pad_X ), u2mic(sch_pad_Y ) - ( sch_net_count * 2540.0 ), u2mic(sch_pad_X) - 2540.0, u2mic( sch_pad_Y ) - ( sch_net_count * 2540.0 ) );
        sch_cmd += c;
        sprintf(c, "LABEL (%f %f)(%f %f );\n", u2mic(sch_pad_X ), u2mic(sch_pad_Y ) - ( sch_net_count * 2540.0 ), u2mic(sch_pad_X) - 2540.0, u2mic(sch_pad_Y ) - ( sch_net_count * 2540.0 ));
        sch_cmd += c;

        sch_net_count++; // add new offset
      }
    }  // signals(S) {
  }  // board(B) { 


 //  sprintf( c, "wire %s %f (%f %f) (%f %f ) 'fred'  0.05 ( 0.1 0.1 ) ( 0.1 2 )


  // write save command
  cmd += lib_cmd;
  sprintf(c, "write;\n");
  cmd += c;
  sprintf(c, "edit '%s';\n", schname );    
  cmd += c;
  cmd += sch_cmd;  
  sprintf(c, "write;\n");
  cmd += c;
  sprintf(c, "edit .brd;\n");    
  cmd += c;
  cmd += pcb_cmd;
  sprintf(c, "edit '%s';\n", schname );    
  cmd += c;
  sprintf(c, "write;\n");
  cmd += c;

  sprintf(c, "run eagle6xx-sch-to-kicad-sch.ulp;\n");
  cmd += c;
  
    
  output(fname, "wtD")
      printf("%s", cmd);

  exit ("SCRIPT '" + fname + "';");

  return 0;
}


