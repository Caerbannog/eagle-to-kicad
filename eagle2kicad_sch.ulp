#usage "<b>Eagle schematic exporting tool  version 1.0 </b>\n"
       "<p>"
       "This ULP can convert an Eagle CAD schematic into KiCAD schematic."
       "<p>"
       "Load any schematic and execute the ULP in the eagle."
       "<p>"
       "<author>Author: juergen.messerer (at) freesurf.ch</author>"
/*
 * CHANGELOG================================================
 * 07.09.2014: Inc version too 1.1 
 *             Thanks  Lachlan   lachlanusa (at) gmail.com
 *
 * 07.09.2014: Fix's for part name placement, and part rowtation.
 *             Thanks  Lachlan   lachlanusa (at) gmail.com
 *
 * 13.08.2014: Add more suport for muliti parts
 *             Thanks  Lachlan   lachlanusa (at) gmail.com
 *
 * 08.08.2014: Bug fix, size conversion bug.
 *             Thanks  Lachlan   lachlanusa (at) gmail.com
 *
 * 03.08.2014: Bug fix, remove bank \n \r from output,  as KiCad wont dos not like bank line's in sch files
 *             Thanks  Lachlan   lachlanusa (at) gmail.com
 *
 * 10.07.2906: Bug fix, thank to Tom Morrison 
 *             Add function write_kicad_dotted_segments()
 *
 * 19.06.2006: Init version        	
*/  

/* ==========================================================================
 * License: This file is released under the license of the GNU Public license
 *          Version 2.
 * ==========================================================================*/   
 
real VERSION   = 1.0;



string g_comboBoxArray[] = { "A0 (1188mm x 840mm)", "A1 (840mm x 594mm)", "A2(594mm x 420mm)",
                             "A3 (420mm x 297mm)", "A4(297mm x 210mm)", 
                             "A5(210mm x 148mm)", "A6(148mm x 105mm)", 
			     "Letter (11 x 8,5)", "Legal (14 x 8.5)", 
			     "Folio  (13 x 8.5)", "Executive (10.5 x 7.25)",
			     "A (11 x 8)", "B (16 x 11)", "C (22 x 16)", "D (32 x 22)", "E (44 x 32)",
			     "User defined" };

string g_sheetSizeArray[] = { "A0", "A1", "A2", "A3", "A4", "A5", "A6", 
                              "Letter", "Legal", "Folio", "Executive", 
			      "A", "B", "C", "D", "E" };			   
 
string g_sheetSizes[]     = { "46800 33070", "33070 23400", "23400 16535", "16535 11700", "11700 8267", "8267 5826", "5826 4133", 
                              "11000 8500", "14000 8500", "13000 8500", "10500", "7250",
			      "11000 8000", "16000 11000", "22000 16000", "32000 22000", "44000 32000" };
			  
int g_selected = 4; // initially selects "A0" 

int g_dimX = 16000;
int g_dimY = 11000;

string monthArray[] = { "JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC" };

string g_strTitle = "";
string g_strDate  = "";
string g_strRev   = "";
string g_strComp  = "";
string g_comment1   = "";
string g_comment2   = "";
string g_comment3   = "";
string g_comment4   = "";

string libsUsed;

real   g_Fact  = 254*32;        // global uMeter to uInch conversion factor
int    g_transY = 11000;         // Y-axis translation factor, depending on the sheet size

// Default version of KiCad sch file
int outPutVersion = 2;
int outPutCombineFootPrints = 1;  // Output part Name's and foot prints which work with the combined footprint KiCad Library
                                  //  Not this is very trick,  we have to conver the Eagle lib to KiKad lib, and output a conflict
                                  //  list which this programe can use to do the part number tranlastion !


//
//replace new line charter with string '\n' as kicad can handel that, but not new line chareter
//
string stripLfCrToEscCRLF( string textString )
{
  string newString;
  int idx = 0;
  int idx2 = 0;


      for ( idx = 0; textString[idx];)
      	{
	  if( ( isspace( textString[idx] )) || ( isprint( textString[idx] )))
	    {
	      if(( textString[idx] == '\n') || ( textString[idx] == '\r' ) )
		{
		  newString =  newString + "\\n"; 
		  idx++;
		  idx2 = idx2 + 2;
		}
	      else
		{
		  newString[idx2] = textString[idx];
		  idx++;
		  idx2++;
		}
	    }
	  else
	    {  // Ok bad chart so replace with ~
	      newString[idx2] = '~';
	      idx++;
	      idx2++;
	    }
      	}
      return newString;
 }
//
// ***** Genrate KiCad Matrix
//
string angleToKiCadMatrix(int angle, int mirror )
{

  switch(angle)
    {
    case 0: // 0 deg's
      return ((mirror ? "-1" : "1") + " 0 0 -1");
      break;

    case 90:  // 90 deg's
      //      return ("0 -1 " + (mirror ? "1" : "-1") + " 0");
      return ("0 " + (mirror ? "1 -1" : "-1 -1") + " 0");
      break;

      case 180: // 180 Deg's
	return ((mirror ? "1" : "-1") + " 0 0 1");
	//	return ("-1 0 0 " + (mirror ? "-1" : "1") );
      break;

    case 270:  // -90 Deg's or 270 Degs
      return ("0 " + (mirror ? "-1" : "1") + " 1 0");
      //      return ("0 1 " + (mirror ? "-1" : "1") + " 0");

      break;
    }
}


//------------------------------------------------------
//write kicad schematic dotted wire notes
//------------------------------------------------------
void write_kicad_dotted_segments( UL_SHEET SH )
{
   SH.wires(W)
   {
      int x1 = W.x1/g_Fact;
      int y1 = W.y1/g_Fact - g_transY;
      int x2 = W.x2/g_Fact;
      int y2 = W.y2/g_Fact - g_transY;

      printf( "Wire Notes Line\n" );
      printf( "%d %d %d %d\n", x1, -y1, x2, -y2 );
   }
}

//------------------------------------------------------
//write text of an instance smashed or not smashed
//------------------------------------------------------
string writeInstanceText( UL_TEXT T, string partPreFix, string partName, int visable, int symYPostionRaw, int enyCorrection, int partAngle, int partMirror  )
{
   // Smashed text of an instance
   int  x        = T.x / g_Fact;
   int  y        = T.y / g_Fact - g_transY;
   //   int  y        symYPostionRaw - ( T.y / g_Fact - g_transY);
   int  angle    = T.angle;
   int  fontSize = T.size/g_Fact;
     //   int  fontSize = T.size/(g_Fact*32);
   char hAlign   = 'L';
   char vAlign   = 'B';
   char orient   = 'H';
   string result;


   //   printf("\n# Text.angle=%d,  Text.mirror=%d,  PartAngle=%d, PartMirror=%d, T.x=%d, T.y=%d\n", angle, T.mirror, partAngle, partMirror, T.x, T.y );

   //   if(( partAngle - angle ) < 0 )
   //     printf("\n# Text.angle=%d,  Text.mirror=%d,  PartAngle=%d, PartMirror=%d\n", angle, T.mirror, partAngle, partMirror );

   

   // add correction to Y  for..   
   //   if( enyCorrection )
   if( 1 )
     {
       if(  symYPostionRaw < T.y )
	   y = ( symYPostionRaw - abs( symYPostionRaw - T.y )) / g_Fact - g_transY ;  // If postive offset, nigtive !
       if ( symYPostionRaw > T.y )
	 y = ( symYPostionRaw + (symYPostionRaw - T.y )) / g_Fact - g_transY;  // if negtive offset 
     }
   

   switch( partAngle - angle )
     {
     case 0:  // funny biz..    even thou text  may show no rowtation,    if the part is rotated we still have to change the postion of the text !!!
       if( partMirror - T.mirror)
	 { // Mirror
	   orient = 'H';
	   hAlign = 'R';
	   vAlign = 'B';
	 }
       else
	 {  // No Mirror
	   orient = 'H';
	   hAlign = 'L';
	   vAlign = 'B';
	 }
       break;

     case 90:
     case -90:
       //       printf("\n# Text.angle=%d,\n", partAngle - angle );
         orient = 'V';
         hAlign = 'L';
         vAlign = 'B';
      break;

      case 180:
      case -180:
	if( partMirror - T.mirror )
	  {
	    orient = 'H';
	    hAlign = 'L';
	    vAlign = 'B';
	  }
	else
	  {
	    orient = 'H';
	    hAlign = 'R';
	    vAlign = 'T';
	  }
      break;

      case 270:
      case -270:
         orient = 'V';
         hAlign = 'R';
         vAlign = 'T';
      break;
   }

   if( outPutVersion == 1 )
     sprintf( result, "\"%s\" %c %d %d %d %.4d %c %c\n", stripLfCrToEscCRLF( T.value ), orient, x, -y, fontSize, visable, hAlign, vAlign );
   if( outPutVersion == 2 )
     sprintf( result, "\"%s\" %c %d %d %d %.4d %c %cNN\n", stripLfCrToEscCRLF( T.value ), orient, x, -y, fontSize, visable, hAlign, vAlign );

   return result;
}

//------------------------------------------------------
//write text segments for nets and busses
//------------------------------------------------------
void writeTextSegments( UL_TEXT T )
{
   char   orient      = 0;
   int    textAngle   = T.angle;
   string textString  = T.value;
   int    fontSize    = T.size/g_Fact;
   int    posX        = T.x/g_Fact;
   int    posY        = T.y/g_Fact - g_transY;
   int    offset      = ((T.size * strlen(T.value))/2)/g_Fact;
                
   switch( textAngle )
   {
      case 0:
         orient = 0;
      break;
 
      case 90:
         orient = 1;
      break;

      case 180:
         orient = 0;
      break;

      case 270:
         orient = 1;
      break;
   }
   printf("Text Label %d %d %d %d ~\n", posX, -posY, orient, fontSize);
   printf("%s\n", textString);
}

//------------------------------------------------------
//write kicad schematic bus segment entries
//------------------------------------------------------
void write_kicad_bus_segments( UL_SHEET SH )
{
   SH.busses(N)
   {
      N.segments(SEG)
      {
         SEG.wires(W) 
	 {
            int x1 = W.x1/g_Fact;
            int y1 = W.y1/g_Fact - g_transY;
            int x2 = W.x2/g_Fact;
            int y2 = W.y2/g_Fact - g_transY;

	    printf( "Wire Bus Line\n" );
	    printf( "%d %d %d %d\n", x1, -y1, x2, -y2 );
	 }
	 
         SEG.junctions(J)
	 {
	    int x = J.x/g_Fact;
	    int y = J.y/g_Fact- g_transY;
	    
	    printf("Connection ~ %d %d\n", x, -y);
	 }
	 
         SEG.texts(T)
         {
	    writeTextSegments(T);
         }
      }
   }
}

//------------------------------------------------------
//write kicad schematic wire segment entries
//------------------------------------------------------
void write_kicad_wire_segments( UL_SHEET SH )
{
   SH.nets(N)
   {
      N.segments(SEG)
      {
         SEG.wires(W) 
         {
            int x1 = W.x1/g_Fact;
            int y1 = W.y1/g_Fact - g_transY;
            int x2 = W.x2/g_Fact;
            int y2 = W.y2/g_Fact - g_transY;

            printf( "Wire Wire Line\n" );

	    if( outPutVersion == 1 )
	      printf( "%d %d %d %d\n", x1, -y1, x2, -y2 );
	    if( outPutVersion == 2 )
	      printf( "\t%d %d %d %d\n", x1, -y1, x2, -y2 );
         }
	 
         SEG.junctions(J)
        {
            int x = J.x/g_Fact;
            int y = J.y/g_Fact- g_transY;
	    
            printf("Connection ~ %d %d\n", x, -y);
        }
	 
         SEG.texts(T)
         {
            writeTextSegments(T);
         }
      }
   }
}

//------------------------------------------------------
//write kicad schematic text entries
//------------------------------------------------------
void write_kicad_text_notes( UL_SHEET S )
{
   S.texts(T) 
   {
      char   orient      = 0;
      int    textAngle   = T.angle;
      string textString  = T.value;
      int    fontSize    = T.size/g_Fact;
      int    posX        = T.x/g_Fact;
      int    posY        = T.y/g_Fact - g_transY;
      int    offset      = ((T.size * strlen(T.value))/2)/g_Fact;
      int    idx        = 0;
      int    idx2        = 0;
      string newString = "";

      //replace new line charter with string '\n' as kicad can handel that, but not new line chareter
      newString =  stripLfCrToEscCRLF( textString );

      switch( textAngle )
      {
      case 0:
	if(T.mirror)
	  orient = 2;
	else
	  orient = 0;
      break;
 
      case 90:
         orient = 1;
      break;

      case 180:
         orient = 2;
      break;

      case 270:
         orient = 3;
      break;
      }

      if( outPutVersion == 1 )
	printf("Text Notes %d %d %d %d ~\n", posX, -posY, orient, fontSize);
      if( outPutVersion == 2 )
	printf("Text Notes %d %d %d %d ~ %s %d\n", posX, -posY, orient, fontSize, "", 0 );

      printf("%s\n", newString);
   } 
}

//------------------------------------------------------
//write kicad schematic noconnect entries
//------------------------------------------------------
void write_kicad_noconnect( UL_SHEET SH )
{
   SH.parts(P)
   {
      P.instances(I)
      {
         I.gate.symbol.pins(PIN)
         {
            if( PIN.direction == PIN_DIRECTION_NC || PIN.name == "NC" )
            {
               int posX = PIN.x / g_Fact ;
               int posY = PIN.y / g_Fact - g_transY;

               printf( "NoConn ~ %d %d\n", posX, -posY );
            }
         }
      }
   }
}

//------------------------------------------------------
//write kicad schematic component entries
//------------------------------------------------------
void write_kicad_components( UL_SHEET S )
{
  S.parts(P)
    {
      if(P.device.package)  // Do we have a package ?
	{

	  //  	  printf("\nP.deviceset.name:%s, P.name:%s, P.device.package.name:%s\n", P.deviceset.name, P.name, P.device.package.name );


	  string valueStr = P.device.name;
	  string nameStr  = P.name;
	  int instanceCount = 0;
	  int numberOfSubParts = 0;

	  if(nameStr == "")
            nameStr= "NNN";
         
	  if( strlen(valueStr) < 1 ) // ????
            valueStr = "1uF";
 
	  // Replace all spaces with '_' in part number
	  // Replace all spaces or '/' with '_' in part number
	  for (int idx = 0; valueStr[idx]; ++idx)
	    {
	      //	      if( valueStr[idx] == ' ' || valueStr[idx] == '/')
	      if( valueStr[idx] == ' ' )
		valueStr[idx] = '_';
	    }

	  //	  printf( "$Comp\n" );
	  //	  	  printf( "##L %s %s\n", valueStr, nameStr );
	  //	  printf( "U %d %d %X\n", 1, 1, time() );
     
	  P.instances(I)
	    {
	      numberOfSubParts++;
	    }


	  P.instances(I)   
	    {
	      char orient = 'H';
	      char hAlign = 'L';
	      char vAlign = 'T';
	      int posX = I.x / g_Fact;
	      int posY = I.y / g_Fact - g_transY;
	      int posYraw = I.y;
	      int count = 0;
	      int partAngle = I.angle;
	      int partMirror = I.mirror;
	      string gateNameSplit[];
	      int getNameSplitCount = 0;
	      string strF0F1F2[];
	      int strF0F1F2foundFlag[] = {0,0,0};
	      string strItext[];
	      string strItextOutPut[];
	      int strItextFoundflag[];
	      string IgateSymText[];
	      string IgateSymTextOutPut[];
	      int IgateSymTextFoundFlag[];


	      // split the gate name to get number form the gate name IE: G$1...
	      if( (getNameSplitCount = strsplit( gateNameSplit, I.gate.name, '$')) < 2 )
		{
		  instanceCount = 1;
		}
	      else
		{
		  instanceCount = strtol( gateNameSplit[1] );
		  if( instanceCount == 0 )
		    instanceCount = 1;  // error of some kind ?
		}

	      printf( "$Comp\n" );
	      printf( "L %s %s\n", valueStr, nameStr );
	      //	      printf( "U %d %d %X\n", 1, 1, time() );
	      //	      printf( "U %d %d %X\n", instanceCount++, 1, time()  );
	      printf( "U %d %d %X\n", instanceCount, 1, time()  );


	      //	      	      printf( "\n## I.name:%s  I.gate.name:%s  I.gate.symbol.name:%s   I.value:%s  X:%d  Y:%d\n", I.name, I.gate.name, I.gate.symbol.name, I.value,  I.x, I.y );



	      printf( "P %d %d\n", posX, -posY );
        
	      count = 0;

	      int ItextCount = 0;
	      int IgateSymolTextCount = 0;

	      strF0F1F2[ 0 ] = nameStr;
	      strF0F1F2[ 1 ] = I.value;
 	      strF0F1F2[ 2 ] = P.device.package.name;

	      // Smash text section, note only the >NAME and >VALUE can be smashed !
	      // if >NAME and >VALUE are not smashed, they wont apear here.
	      // But in  I.gate.symbol.texts(T) section, also note depending on if the 
	      // >NAME and/or >VALUE have been changed deleted/added back in the eagle lib,  then sch is update from
	      // that eagle lib's, the >NAME and/or >VALUE they may apear in any order in I.gate.symbol.texts(T)
	      // text section's !! how brain dead is that.. !!
	      I.texts(T)
		{
		  strItext[ ItextCount ] = T.value;
		  strItextOutPut[ ItextCount ] = writeInstanceText(  T, nameStr, valueStr, 0, posYraw, numberOfSubParts-1, partAngle, partMirror );
		  strItextFoundflag[ ItextCount ] = 0;
		  strF0F1F2foundFlag[ ItextCount ] = 0;
		  ItextCount++;
		}
	      // None smash section
	      I.gate.symbol.texts(T)
		{
		  IgateSymText[ IgateSymolTextCount ] = T.value;
		  IgateSymTextOutPut[ IgateSymolTextCount ] = writeInstanceText( T, nameStr, valueStr, 0, posYraw, numberOfSubParts-1, partAngle, partMirror );
		  IgateSymTextFoundFlag[ IgateSymolTextCount ] = 0;
		  strF0F1F2foundFlag[ IgateSymolTextCount ] = 0;
		  IgateSymolTextCount++;  
		}

	      /*
	      for( count = 0; count < ItextCount; count++ )
		{
		  printf("\n#count:%d\tstrItext: %s", count, strItext[ count ] );
		  printf("\n#count:%d\tstrItextOut: %s", count, strItextOutPut[ count ] );
		}
	      printf("\n");
	      for( count = 0; count < IgateSymolTextCount; count++ )
		{
		  printf("\n#count:%d\tIgateSymolText: %s", count,  IgateSymText[ count ] );
		  printf("\n#count:%d\tIgateSymolTextOut: %s", count, IgateSymTextOutPut[  count ] );
		}
	      printf("\n");
	      */

	      count =  0;

	      int ct = 0;
	      int found = 0;
	      //Out Put F0...
	      //	      for( count = 0; count < 3; count++ )
	      //		{

		  for( ct = 0; ct < 3; ct++)  // find header 
		    {
		      for( int ct1 = 0; ct1 < ItextCount; ct1++ )
			{
			  if( ( strstr( strItext[ ct1 ], strF0F1F2[ ct ], 0) == 0) && ( ct == 0) || ( strF0F1F2[ ct ] == strItext[ ct1 ] ))
			    //			  if( strF0F1F2[ ct ] == strItext[ ct1 ] )  // found  so output it
			    {
			      //			      printf("\nfound!!!  ct=%d ct1=%d  %s   %s", ct, ct1,  strF0F1F2[ct], strItext[ ct1 ] );

			      printf("F %d %s", ct,  strItextOutPut[ ct1 ]);

			      strF0F1F2foundFlag[ ct ] = 1;
			      strItextFoundflag[ ct1 ] = 1;  //  Mark so we don't output this
			      found = 1;
			      break;
			    }
			  else
			    strF0F1F2foundFlag[ ct ] = 0; // Mark as not found
			}
		      if(found)
			{
			  found = 0;
			  continue;
			}

		      for( ct1 = 0; ct1 < IgateSymolTextCount; ct1++ )
			{
			  if( ( strstr( IgateSymText[ ct1 ], strF0F1F2[ ct ], 0) == 0) && ( ct == 0) || ( strF0F1F2[ ct ] == IgateSymText[ ct1 ] ))
			    //			  if( strF0F1F2[ ct ] == IgateSymText[ ct1 ] )  // found  so output it
			    {
			      //			      printf("\nXXfound!!!  ct=%d ct1=%d %s    %s",  ct, ct1, strF0F1F2[ct], IgateSymText[ ct1 ] );

			      printf("F %d %s", ct,  IgateSymTextOutPut[ ct1 ]);
			      //			      printf("Fx %d %s", ct,  IgateSymTextOutPut[ ct1 ]);

			      strF0F1F2foundFlag[ ct ] = 1;
			      IgateSymTextFoundFlag[ ct1 ] = 1;  //  Mark so we don't output this
			      found = 1;
			      break;
			    }
			  else
			    strF0F1F2foundFlag[ ct ] = 0; // Mark as not found
			}
		      if(found)
			{
			  found = 0;
			  continue;
			}

		      //		      printf("\n****Not found!!!  ct=%d ct1=%d  %s\n",  ct, ct1, strF0F1F2[ct] );
		      // Ok no place to put it so just sick it above the refance point
		      if( outPutVersion == 1 )
			printf("F %d \"%s\" H %d %d 70 %.4d %c %c\n", ct,  strF0F1F2[ ct ], 
			       (posX - 10), -(posY+10+(ct*100)), 1, hAlign, vAlign );
		      if( outPutVersion == 2 )
			printf("F %d \"%s\" H %d %d 70 %.4d %c %cNN\n", ct, strF0F1F2[ ct ], 
			       (posX - 10), -(posY+10+(ct*100)), 1, hAlign, vAlign );

		    }
		    
		  //		}

	      // Out put smashed text
	      ct = 3;
	      for( int ct1 = 0; ct1 < ItextCount; ct1++ )
		{
		  if( strItextFoundflag[ ct1 ] == 0 )  // found  so output it
		    {
		      printf("F %d %s", ct,  strItextOutPut[ ct1 ] );
		      strItextFoundflag[ ct1 ] = 1;  //  Mark so we don't output this
		    }
		  ct++;
		}
	      // Out put none smashed text
	      for( ct1 = 0; ct1 < IgateSymolTextCount; ct1++ )
		{
		  if( IgateSymTextFoundFlag[ ct1 ] == 0 )  // found  so output it
		    {
		      printf("F %d %s", ct,  IgateSymTextOutPut[ ct1 ] );
		      IgateSymTextFoundFlag[ ct1 ] = 1;  //  Mark so we don't output this
		    }
		  ct++;
		}
	    

	      //	      if( outPutVersion == 1 )
	      //		printf("F 2 \"%s\" H %d %d 70 %.4d %c %c\n", strF0F1F2[ 2 ], 
	      //		       (posX - 10), -(posY+10), 1, hAlign, vAlign );
	      //	      if( outPutVersion == 2 )
	      //		printf("F 2 \"%s\" H %d %d 70 %.4d %c %cNN\n", strF0F1F2[ 2 ], 
	      //		       (posX - 10), -(posY+10), 1, hAlign, vAlign );


	      //	      printf( "\t%-4d %-4d %-4d\n", 1, posX, -posY );
	      printf( "\t%-4d %-4d %-4d\n", instanceCount, posX, -posY );
	      //              printf( "\n#t\tAngle:%d,    Mirror:%d\n", partAngle, partMirror );	      
	      printf( "\t%s\n", angleToKiCadMatrix(partAngle, partMirror ));
	      //	      printf( "\t%-4d %-4d %-4d %-4d\n", 1, 0, 0, -1 );
	      printf( "$EndComp\n" );
	    }
	  //	  printf( "$EndComp\n" );
	}
      else 
	{  //*****  Ok no package but it may be a power/ground.. ?

	  //	  printf("\nP.deviceset.name:%s, P.name:%s, P.device.package.name:%s\n", P.deviceset.name, P.name, P.device.package.name );


	  string valueStr = P.device.name;
	  string nameStr  = P.name;
	  int instanceCount = 1;
	  int numberOfSubParts = 0;

	  P.instances(I)
	    {
	      numberOfSubParts++;
	    }

	  if(nameStr == "")
            nameStr= "NNN";
         
	  if( strlen(valueStr) < 1 ) // ????
            valueStr = "1uF";
 
	  // Replace all spaces or '/' with '_' in part number
	  for (int idx = 0; valueStr[idx]; ++idx)
	    {
	      if( valueStr[idx] == ' ' || valueStr[idx] == '/')
		valueStr[idx] = '_';
	    }

	  //	  printf( "$Comp\n" );
	  //	  printf( "L %s %s\n", valueStr, nameStr );
	  //	  printf( "U %d %d %X\n", 1, 1, time() );
     
	  P.instances(I)   
	    {
	      char orient = 'H';
	      char hAlign = 'L';
	      char vAlign = 'T';
	      int posX = I.x / g_Fact;
	      int posY = I.y / g_Fact - g_transY;
	      int posYraw = I.y;
	      int count = 0;
	      int partAngle = I.angle;
	      int partMirror = I.mirror;
	      string gateNameSplit[];
	      int getNameSplitCount = 0;


	      // split the gate name to get number form the gate name IE: G$1...
	      if( (getNameSplitCount = strsplit( gateNameSplit, I.gate.name, '$')) < 2 )
		{
		  instanceCount = 1;
		}
	      else
		{
		  instanceCount = strtol( gateNameSplit[1] );
		  if( instanceCount == 0 )
		    instanceCount = 1;  // error of some kind ?
		}



	      printf( "$Comp\n" );
	      printf( "L %s %s\n", valueStr, nameStr );
	      //	      printf( "U %d %d %X\n", 1, 1, time() );
	      //	      printf( "U %d %d %X\n", instanceCount++, 1, time()  );
	      printf( "U %d %d %X\n", instanceCount, 1, time()  );


	      //	      printf( "\n## I.name:%s  I.gate.name:%s  I.gate.symbol.name:%s  X:%d  Y:%d\n", I.name, I.gate.name, I.gate.symbol.name,  I.x, I.y );




	      printf( "P %d %d\n", posX, posY );
	      I.texts(T)
		{   
		  printf("F %d %s", count,  writeInstanceText( T, nameStr,  valueStr, 1, posYraw, numberOfSubParts-1, partAngle, partMirror));
		  count++;
		}
	      //	      count = 0;
	      /*	      I.gate.symbol.texts(T)
		{
		  writeInstanceText( T, count, nameStr, posY );
		  count++;  
		}
	      */


	      /*
	      if( outPutVersion == 1 )
		printf("F 2 \"%s\" V %d %d 70 %.4d %c %c\n", P.device.name, 
		       posX, -posY, 0, hAlign, vAlign );
	      if( outPutVersion == 2 )
		printf("F 2 \"%s\" V %d %d 70 %.4d %c %cNN\n", P.device.name, 
		       posX, -posY, 0, hAlign, vAlign );
	      */



	      //	      printf( "\t%-4d %-4d %-4d\n", 1, posX, -posY );
	      printf( "\t%-4d %-4d %-4d\n", instanceCount, posX, -posY );


	      
	      //              printf( "\n#t\tAngle:%d,    Mirror:%d\n", partAngle, partMirror );	      

	      printf( "\t%s\n", angleToKiCadMatrix(partAngle, partMirror ));
	      //	      printf( "\t%-4d %-4d %-4d %-4d\n", 1, 0, 0, -1 );

	      printf( "$EndComp\n" );
	    }
	  //	  printf( "$EndComp\n" );


	}
    } // Parts
}

//------------------------------------------------------
//write kicad schematic header
//------------------------------------------------------
void write_kicad_header( UL_SCHEMATIC SCH )
{
  int totalSheets = 0;
   int t = time();

   if(outPutVersion == 1)
     printf("EELAYER %d %d\n", 23, 0 );

   if(outPutVersion == 2)
     printf("EELAYER %d %d\n", 24, 0 );

   printf("EELAYER END\n");
   
   if( g_selected >= 0 && g_selected < 16 )
      printf("$Descr %s %s\n", g_sheetSizeArray[g_selected], g_sheetSizes[g_selected]);
   else
      printf("$Descr User %d %d\n", g_dimX, g_dimY );
   
   if(outPutVersion == 2)
     printf("encoding utf-8\n");

   SCH.sheets(S)
   {
      ++totalSheets;
   } 
     
   SCH.sheets(S)
   {
      printf("Sheet %d %d\n", S.number, totalSheets);
   }

   if( g_strTitle == "" )
   {
      int charPos = strrchr(SCH.name, '/');
      g_strTitle = strsub(SCH.name, charPos+1, strlen(SCH.name)-charPos);   
   }
   
   printf("Title \"%s\"\n", g_strTitle );

   if(g_strDate == "")   
      printf("Date \"%d %s %d\"\n", t2day(t), monthArray[t2month(t)], t2year(t) );
   else
      printf("Date \"%s\"\n", g_strDate );
      
   printf("Rev \"%s\"\n", g_strRev );
   printf("Comp \"%s\"\n", g_strComp );
   printf("Comment1 \"%s\"\n", g_comment1 );
   printf("Comment2 \"%s\"\n", g_comment2 );
   printf("Comment3 \"%s\"\n", g_comment3 );
   printf("Comment4 \"%s\"\n", g_comment4 );
   printf("$EndDescr\n");
}

//------------------------------------------------------
//write index of modules
//------------------------------------------------------
void write_kicad_schematics( string fileName )
{
   output(fileName, "Fwt") 
   {
      if(schematic)
      {
         schematic(SCH) 
         { 
            string libString;
            int t = time();

	    if(outPutVersion == 1)
	      {
		printf("EESchema Schematic File Version 1\n"); 
		printf("LIBS:");
		SCH.libraries(LIB)
		  {
		    string tmpString = "";
		    sprintf(tmpString, "%s,", LIB.name);
		    libsUsed += LIB.name + "\n";
		    libString = libString + tmpString;
		  }	
		printf("%s\n", strsub(libString, 0, strlen(libString)-1 ) );     
	      }

	    if(outPutVersion == 2)
	      {
		printf("EESchema Schematic File Version 2\n"); 

		SCH.libraries(LIB)
		  {
		    printf("LIBS:");
		    string tmpString = "";
		    printf("%s\n", LIB.name);
		    libsUsed += LIB.name + "\n";
		  }	
	      }


            SCH.sheets(SH)
            {
               write_kicad_header(SCH);   
               write_kicad_text_notes( SH );
//	       printf("\n");
	       write_kicad_components( SH );
	       write_kicad_noconnect( SH );
               write_kicad_wire_segments( SH );
               write_kicad_bus_segments( SH );
	       write_kicad_dotted_segments( SH );
            }
            printf("$EndSCHEMATC\n");
         }
      }  
   }   
}


//------------------------------------------------------
// Global mod_ and lib_name
//------------------------------------------------------
string sch_name ;   

//------------------------------------------------------
// Y axis translation factor
//------------------------------------------------------
void setTransY()
{
   string pageDimension[];
   int n = strsplit(pageDimension, g_sheetSizes[g_selected], ' ');
   
   g_transY = strtol(pageDimension[1]) - 500;
}

//------------------------------------------------------
// Select the path where the schematic will be saved 
//------------------------------------------------------
void openSchematicPath( string startPath )
{
   string dirName = "";
   string stringArray[];
   dirName = dlgDirectory("Select a directory", startPath);
   
   if( dirName != "" )
   {
      schematic(S) 
      {
         int n = 0;
         string tmpName = S.name; 
         int nr = strsplit(stringArray, tmpName, '/');
         sch_name = dirName + "/" + stringArray[nr-1];
         sch_name = strsub(sch_name , 0, strlen(sch_name) - 4) + "_.sch";
      }
   }
}

//------------------------------------------------------
// main program 
//------------------------------------------------------
int result;
int space = 10;
string ref;
string titleStr;

sprintf(titleStr, "Export Eagle schematic to KiCAD, Version: %.1f", VERSION);

if (schematic)  
{
   schematic(S) 
   {
      sch_name = strsub(S.name, 0, strlen(S.name) - 4) + "_.sch";
   }
}
else 
{
   dlgMessageBox("Please run from schematic editor." ); 
   exit(EXIT_FAILURE);
}

result = dlgDialog(titleStr)
{
	  
   dlgTabWidget 
   {
      //=====================TAB1=============================================================
      dlgTabPage("Output:") 
      {     

        dlgHBoxLayout dlgSpacing(400);
        dlgStretch(0);
	dlgSpacing(space);
        dlgLabel("Export to file:");
        dlgStretch(0);
        dlgHBoxLayout
	{
	   dlgSpacing(space);
           dlgStringEdit(sch_name);
	   dlgSpacing(space);
	   dlgPushButton("...") openSchematicPath("C:\\");
	   dlgSpacing(space);
	}
	dlgStretch(10);
     }
     //=====================TAB2=============================================================
      dlgTabPage("Sheet:") 
      { 
         dlgSpacing(space);
	dlgHBoxLayout
	{
	   dlgSpacing(space);
	   dlgComboBox(g_comboBoxArray, g_selected)
	   { 
              setTransY();
	   }
	   dlgStretch(1);
	   dlgSpacing(space);
	}
	dlgSpacing(space);
	
	dlgGroup("User defined:")
	{
	
	   dlgHBoxLayout
	   {
              dlgLabel("Size X:");
	      dlgIntEdit(g_dimX, 0, 99999);
	      
	      dlgSpacing(space);
	      
	      dlgLabel("Size Y:");
	      dlgIntEdit(g_dimY, 0, 99999);
	    }
	 }
      }
      //=====================TAB1=============================================================
      dlgTabPage("Comments:") 
      {  
         dlgHBoxLayout
         {
            dlgLabel("Title:");
	          dlgStringEdit(g_strTitle);
	       }
	       
	       dlgHBoxLayout
         {
            dlgLabel("Date:");
	          dlgStringEdit(g_strDate);
	       }
	 
         dlgHBoxLayout
         {
            dlgLabel("Rev:");
            dlgStringEdit(g_strRev);
         }
	 
         dlgHBoxLayout
         {
            dlgLabel("Comp:");
            dlgStringEdit(g_strComp);
         }
	 
         dlgHBoxLayout
         {
            dlgLabel("Comment1:");
            dlgStringEdit(g_comment1);
         }
	 
         dlgHBoxLayout
         {
            dlgLabel("Comment2:");
            dlgStringEdit(g_comment2);
         }
	 
         dlgHBoxLayout
         {
            dlgLabel("Comment3:");
            dlgStringEdit(g_comment3);
         }
	 
         dlgHBoxLayout
         {
            dlgLabel("Comment4:");
            dlgStringEdit(g_comment4);
         }  
      }
   }
   dlgVBoxLayout 
   {
      dlgStretch(0);
      dlgHBoxLayout 
      {
         dlgStretch(1);
         dlgPushButton("+OK") dlgAccept();
	 dlgSpacing(space);
         dlgPushButton("-Cancel") dlgReject();
         dlgStretch(0);
	 dlgSpacing(space);
      }
      dlgStretch(10);
   };
};

  if(result)
  {
    write_kicad_schematics(sch_name);
    dlgMessageBox("CONVERSION  COMPLETE\n" + "Libs list used\n\n" + libsUsed ); 
  }
  else 
    exit(EXIT_FAILURE);
    
  exit(EXIT_SUCCESS);
